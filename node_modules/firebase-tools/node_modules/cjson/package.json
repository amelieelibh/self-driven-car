{
  "name": "cjson",
  "description": "cjson - Commented JavaScript Object Notation. It is a json loader, which parses only valid json files, but with comments enabled. Useful for loading configs.",
  "version": "0.3.3",
  "repository": {
    "type": "git",
    "url": "git://github.com/kof/node-cjson.git"
  },
  "keywords": [
    "json",
    "parser",
    "comments",
    "config",
    "loader"
  ],
  "author": {
    "name": "Oleg Slobodskoi",
    "email": "oleg008@gmail.com"
  },
  "engines": {
    "node": ">= 0.3.0"
  },
  "dependencies": {
    "json-parse-helpfulerror": "^1.0.3"
  },
  "scripts": {
    "test": "node ./test/test.js"
  },
  "license": "MIT",
  "readme": "[![build status](https://secure.travis-ci.org/kof/node-cjson.png)](http://travis-ci.org/kof/node-cjson)\n## CJSON (Commented JavaScript Object Notation) is a comments enabled json config loader.\n\nJSON has a good spec, is implemented in every language, has easy to read syntax and is much more powerful than ini files.\n\nJSON is perfect for writing config files, except of one problem - there is no comments, but sometimes config files get large and need to be commented.\n\nWell, you could just evaluate json file as a JavaScript using one-liner, right?\n\nThe purpose of this module is to avoid dirty JavaScript configs and to enable clean, consistent, secure, portable and JSON valid notation.\n\nCJSON supports JavaScript style comments: singleline \"//\" and  multiline \"/**/\". It takes care about comments inside of strings.\n\nExample of such shiny config file:\n\n```javascript\n/*\n * This is my app configuration file.\n *\n */\n{\n\t\"host\": \"localhost\",\n\t// app is listening on this port\n\t\"port\": 8888\n}\n```\n\n## API\n\n### load the module\n\tvar cjson = require('cjson');\n\n### cjson.load(path, [options]);\n\nLoad config file from given path, array of paths or directory. Second parameter is optional and can be a boolean or object.\n\n- `path` {String|Array} absolute path to the file, array of paths or directory\n- `options` {Boolean|Object} optional options. If you pass `true` as second param, its the same like `    {merge: true}` and will merge all configs together.\n\n\n`options` defaults:\n```javascript\n{\n\t// merge all passed/found config files, see `cjson.extend`\n    merge: false,\n    // allows you to do some string replacements, see `cjson.replace`.\n    replace: null,\n    // freeze config recursively, see `cjson.freeze`\n    freeze: false,\n    // you can use any other extension for your config files, f.e. .cjson\n    ext: '.json',\n    // you can use any parser you want. the default uses JSON.parse for maximum\n    // speed, if it throws it uses uses an alternative parser to give more\n    // helpful errors\n    parse: jph.parse\n}\n```\n\nExamples:\n\n```javascript\n// just one config\nvar conf = cjson.load('/path/to/your/config.json');\n\n// array of configs\nvar conf = cjson.load(['/path/to/your/config1.json', '/path/to/your/config2.json']);\n\n//output\n{\n\tconfig1: {key1: 'value1'}\n\tconfig2: {key2: 'value2'}\n}\n\n\n// use optional merge parameter\n// array of configs\nvar conf = cjson.load(['/path/to/your/config1.json', '/path/to/your/config2.json'], true);\n\n// output\n{\n\tkey1: 'value1',\n\tkey2: 'value2'\n}\n\n\n// load all config files from a directory\nvar conf = cjson.load('/path/to/your/configs');\n\n// overwriting dev config with production\nvar paths = ['/path/to/conf.json'];\nif (process.env.NODE_ENV ==='production')Â {\n\tpaths.push('/path/to/conf-prod.json');\n}\nvar conf = cjson.load(paths, true);\n```\n\n### cjson.extend([deep], target, object1, [objectN])\n\nMerge the contents of two or more objects together into the first object.\n\n- `deep` If true, the merge becomes recursive.\n- `target` The object to extend. It will receive the new properties.\n- `object1` An object containing additional properties to merge in.\n- `objectN` Additional objects containing properties to merge in.\n\nExample:\n\n```javascript\nvar object = cjson.extend({}, object1, object2);\n```\n\n### cjson.decomment(str)\n\nRemove JavaScript style comments, singleline - '//' and multiline - '/**/'. It takes care\nabout comments inside of strings and escaping.\n\n### cjson.parse(str, [reviver])\n\nLike `JSON.parse`, but it takes care about comments. Optional `reviver` argument\nis for `JSON.parse` method and will be called for every key and value at every level\nof the final result\n\n### cjson.replace(str, obj)\n\nReplace all strings `{{key}}` contained in `{key: 'value'}`, where `key` can be any\nproperty of passed `obj`.\n\nExample:\n```javascript\nvar str = '{\"path\": \"{{root}}/src\"}'; // json file contents\ncjson.replace(str, {root: '/usr'}); // '{\"path\": \"/usr/src\"}'\n```\n### cjson.freeze(obj)\n\nRecursively freeze an object.\n\n\n## Installation\n\n\tnpm install cjson\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/kof/node-cjson/issues"
  },
  "homepage": "https://github.com/kof/node-cjson",
  "_id": "cjson@0.3.3",
  "_from": "cjson@>=0.3.1 <0.4.0"
}
